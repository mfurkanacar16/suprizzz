<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Sevgililer G√ºn√ºn Kutlu Olsun ‚ù§Ô∏è</title>
<style>
  html,body{ margin:0; height:100%; overflow:hidden; background:#000; }
  body{ touch-action:none; }
  canvas{ display:block; width:100vw; height:100vh; }

  #msg{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    color:#fff; font: 16px monospace; text-align:center;
    background: rgba(0,0,0,0.85); padding:20px 24px; border-radius:14px;
    z-index:10; display:none;
    white-space: pre-line;
    border: 2px solid rgba(255,100,100,0.5);
    font-size: 20px;
    box-shadow: 0 0 20px rgba(255, 50, 50, 0.4);
  }

  /* Love Score G√∂stergesi */
  #loveScore{
    position:fixed; top:20px; right:20px;
    font: bold 24px monospace; color: #ff6b81;
    text-shadow: 1px 1px 0 #000;
    z-index: 15;
    background: rgba(0,0,0,0.3);
    padding: 5px 10px; border-radius: 10px;
  }

  /* === Dƒ∞KEY EKRAN UYARISI === */
  #rotateOverlay{
    position:fixed; inset:0; z-index:999;
    display:none;
    background: rgba(0,0,0,0.92);
    color:#fff;
    font: 18px monospace;
    align-items:center;
    justify-content:center;
    text-align:center;
    padding:24px;
  }
  #rotateOverlay .box{
    max-width:520px;
    background: rgba(255,255,255,0.06);
    border:1px solid rgba(255,255,255,0.12);
    border-radius:14px;
    padding:18px 16px;
  }
  #rotateOverlay .big{ font-size:42px; margin-bottom:10px; }
  /* ‚úÖ TAM EKRAN BUTON STƒ∞Lƒ∞ Sƒ∞Lƒ∞NDƒ∞ */

  /* === JOYSTICK === */
  #joy{
    position:fixed;
    left:18px;
    bottom:18px;
    width:140px;
    height:140px;
    z-index:20;
    display:flex;
    align-items:center;
    justify-content:center;
    user-select:none;
    -webkit-user-select:none;
    touch-action:none;
  }
  #joyBase{
    width:140px; height:140px;
    border-radius:999px;
    background: rgba(255,255,255,0.08);
    border: 2px solid rgba(255,255,255,0.14);
    box-shadow: 0 14px 35px rgba(0,0,0,0.35) inset;
    position:relative;
  }
  #joyKnob{
    width:56px; height:56px;
    border-radius:999px;
    background: rgba(255,255,255,0.16);
    border: 2px solid rgba(255,255,255,0.22);
    position:absolute;
    left:50%; top:50%;
    transform: translate(-50%,-50%);
    box-shadow: 0 10px 22px rgba(0,0,0,0.30);
  }
  @media (max-width: 420px){
    #joy{ width:120px; height:120px; }
    #joyBase{ width:120px; height:120px; }
    #joyKnob{ width:50px; height:50px; }
  }

  /* Saƒü alt butonlar */
  .btnCircle{
    position:fixed;
    width:80px; 
    height:80px;
    border-radius:999px;
    z-index:20;
    background: rgba(255,255,255,0.10);
    border: 2px solid rgba(255,255,255,0.18);
    color:#fff;
    font: 12px monospace;
    display:flex;
    align-items:center;
    justify-content:center;
    user-select:none;
    -webkit-user-select:none;
    touch-action:none;
    text-align: center;
    cursor: pointer;
  }
  .btnCircle:active{ transform: translateY(1px); background: rgba(255,255,255,0.25); }
  
  /* Buton Konumlarƒ± */
  #jumpBtn{ right: 20px; bottom: 130px; }
  #atkBtn { right: 20px; bottom: 30px; background: rgba(255, 50, 50, 0.2); }
  #atk2Btn{ right: 110px; bottom: 30px; background: rgba(50, 150, 255, 0.2); }
</style>
</head>
<body>

<!-- ‚úÖ KNIFE SFX (EKLENDƒ∞) -->
<audio id="sfx-knife" src="knife.mp3" preload="auto"></audio>

<div id="loveScore">Sevgi: 0 ‚ù§Ô∏è</div>
<div id="msg"></div>

<div id="rotateOverlay">
  <div class="box">
    <div class="big">üì±‚ÜîÔ∏è</div>
    <div>OYUN YATAY OYNANIR<br>Telefonu <b>YAN</b> √ßevir.</div>
    <!-- ‚úÖ Tam Ekran A√ß butonu kaldƒ±rƒ±ldƒ± -->
  </div>
</div>

<div id="joy">
  <div id="joyBase">
    <div id="joyKnob"></div>
  </div>
</div>

<div id="jumpBtn" class="btnCircle">ZIPIZIPI<br>(JUMP)</div>
<div id="atkBtn" class="btnCircle">VUR</div>
<div id="atk2Btn" class="btnCircle">AT</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const msg = document.getElementById("msg");
const loveScoreEl = document.getElementById("loveScore");

const rotateOverlay = document.getElementById("rotateOverlay");
/* ‚úÖ fsBtn kaldƒ±rƒ±ldƒ± */

/* =========================
   üîä KNIFE SOUND SYSTEM (EKLENDƒ∞)
   ========================= */
const knifeSfx = document.getElementById("sfx-knife");
let audioUnlocked = false;

function unlockAudioOnce(){
  if(audioUnlocked) return;
  audioUnlocked = true;
  try{
    knifeSfx.volume = 0.6;
    const p = knifeSfx.play();
    if(p && p.then){
      p.then(()=>{
        knifeSfx.pause();
        knifeSfx.currentTime = 0;
      }).catch(()=>{});
    }
  }catch(e){}
}
document.addEventListener("pointerdown", unlockAudioOnce, { once:true });
document.addEventListener("touchstart", unlockAudioOnce, { once:true });
document.addEventListener("keydown", unlockAudioOnce, { once:true });

function playKnifeSfx(){
  if(!audioUnlocked) return;
  try{
    knifeSfx.pause();
    knifeSfx.currentTime = 0;
    knifeSfx.play().catch(()=>{});
  }catch(e){}
}
/* ========================= */

function resize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(window.innerWidth * dpr);
  canvas.height = Math.floor(window.innerHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener("resize", resize);
resize();

// === CAN & PUAN ===
let hp = 10;
const MAX_HP = 10;
let loveScore = 0; // SEVGƒ∞ PUANI

// ====== ASSETS ======
const BG_LIST = [
  "forest.png",
  "forest1.png",
  "forest2.png"
];

const SRC_PLAYER = "girl.png";
const SRC_WITCH  = "witch.png";
const SRC_ELF    = "elf.png";
const SRC_STONE  = "stone.png";
const SRC_KNIFE  = "knife.png";
const SRC_DONKEY = "esek.png"; 
const SRC_LOVE   = "love.png";

const BG_CROP_TOP = 0.00;
const BG_CROP_BOTTOM = 0.00;
let GROUND_LINE = 0.78; 

function loadImg(src){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = () => reject(src);
    img.src = src;
  });
}

async function loadAssets(){
  msg.style.display = "block";
  msg.style.color = "#fff";
  msg.textContent = "Loading assets...";
  try{
    const bgImgs = await Promise.all(BG_LIST.map(loadImg));
    const [playerImg, witchImg, elfImg, stoneImg, knifeImg, donkeyImg, loveImg] = await Promise.all([
      loadImg(SRC_PLAYER),
      loadImg(SRC_WITCH),
      loadImg(SRC_ELF),
      loadImg(SRC_STONE),
      loadImg(SRC_KNIFE),
      loadImg(SRC_DONKEY),
      loadImg(SRC_LOVE)
    ]);
    msg.style.display = "none";
    return { bgImgs, playerImg, witchImg, elfImg, stoneImg, knifeImg, donkeyImg, loveImg };
  }catch(badSrc){
    msg.style.display = "block";
    msg.style.color = "#ff5a5a";
    msg.innerHTML =
      "ASSET BULUNAMADI ‚ùå<br><br>" +
      "Bulunamayan: <b>" + badSrc + "</b><br><br>" +
      "L√ºtfen klas√∂re <b>love.png</b> eklediƒüinden emin ol.";
    throw new Error("Asset missing: " + badSrc);
  }
}

/* ======== ORIENTATION (FULLSCREEN YOK) ======== */
function isPortrait(){
  return window.matchMedia && window.matchMedia("(orientation: portrait)").matches;
}
function updateOrientationUI(){
  rotateOverlay.style.display = isPortrait() ? "flex" : "none";
}
window.addEventListener("orientationchange", ()=>{ updateOrientationUI(); setTimeout(resize,150); });
updateOrientationUI();

// ======== JOYSTICK ========
const joy = document.getElementById("joy");
const joyBase = document.getElementById("joyBase");
const joyKnob = document.getElementById("joyKnob");

let joyActive = false;
let joyCenter = {x:0,y:0};
let joyVec = {x:0,y:0}; 

function setJoyCenter(){
  const r = joyBase.getBoundingClientRect();
  joyCenter.x = r.left + r.width/2;
  joyCenter.y = r.top  + r.height/2;
}
setJoyCenter();
window.addEventListener("resize", setJoyCenter);

function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

function joyMove(clientX, clientY){
  const dx = clientX - joyCenter.x;
  const dy = clientY - joyCenter.y;
  const maxR = joyBase.getBoundingClientRect().width * 0.35;

  const dist = Math.hypot(dx,dy);
  const nx = dist > 0 ? dx/dist : 0;
  const ny = dist > 0 ? dy/dist : 0;

  const limited = Math.min(dist, maxR);
  const kx = nx * limited;
  const ky = ny * limited;

  joyKnob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;

  joyVec.x = clamp(kx / maxR, -1, 1);
  joyVec.y = clamp(ky / maxR, -1, 1);
}

function joyReset(){
  joyKnob.style.transform = "translate(-50%,-50%)";
  joyVec.x = 0; joyVec.y = 0;
}

joy.addEventListener("pointerdown", (e)=>{
  joyActive = true;
  joy.setPointerCapture(e.pointerId);
  joyMove(e.clientX, e.clientY);
});
joy.addEventListener("pointermove", (e)=>{
  if(!joyActive) return;
  joyMove(e.clientX, e.clientY);
});
joy.addEventListener("pointerup", ()=>{
  joyActive = false;
  joyReset();
});
joy.addEventListener("pointercancel", ()=>{
  joyActive = false;
  joyReset();
});

// ======== INPUT (PC) ========
let keys = {};
document.addEventListener("keydown", e=> keys[e.key]=true);
document.addEventListener("keyup", e=> keys[e.key]=false);

// ======== GAME STATE ========
let scale = 1;
function computeScale(){
  const s = window.innerHeight / 720;
  scale = Math.max(0.9, Math.min(1.6, s));
}

let player = {
  x:120, y:0, w:180, h:180,
  speed:6,
  vy:0,
  grounded:true,
  flashTimer: 0
};

let bullets = []; 
let enemies = [];
let stones = [];
let hearts = []; 
let particles = []; 
let donkeyNPC = null; 

function groundLineY(){ return window.innerHeight * GROUND_LINE; }
function groundY(){ return groundLineY() - player.h; }

function aabb(a,b){
  return a.x < b.x+b.w && a.x+a.w > b.x &&
         a.y < b.y+b.h && a.y+a.h > b.y;
}

function drawImageCover(img, dx, dy, dw, dh, cropTop=0, cropBottom=0){
  const swFull = img.width;
  const shFull = img.height;

  const cropY = Math.floor(shFull * cropTop);
  const cropH = Math.floor(shFull * (1 - cropTop - cropBottom));

  const sw = swFull;
  const sh = Math.max(1, cropH);

  const s = Math.max(dw / sw, dh / sh);
  const rw = sw * s;
  const rh = sh * s;

  const x = dx + (dw - rw) / 2;
  const y = dy + (dh - rh) / 2;

  ctx.drawImage(img, 0, cropY, sw, sh, x, y, rw, rh);
}

// ======= KALP √áƒ∞Zƒ∞Mƒ∞ (CAN BARI) =======
function drawHeart(x, y, size, color) {
  ctx.save();
  ctx.fillStyle = color;
  ctx.beginPath();
  let topCurveHeight = size * 0.3;
  ctx.moveTo(x, y + topCurveHeight);
  ctx.bezierCurveTo(x, y, x - size / 2, y, x - size / 2, y + topCurveHeight);
  ctx.bezierCurveTo(x - size / 2, y + (size + topCurveHeight) / 2, x, y + size, x, y + size);
  ctx.bezierCurveTo(x, y + size, x + size / 2, y + (size + topCurveHeight) / 2, x + size / 2, y + topCurveHeight);
  ctx.bezierCurveTo(x + size / 2, y, x, y, x, y + topCurveHeight);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// ======= MESSAGE =======
let msgTimer = 0;
function showCenterMsg(text, frames=60){
  msg.style.display = "block";
  msg.style.color = "#fff";
  msg.textContent = text;
  msgTimer = frames;
}

// ======= FAKE WALK + DUST =======
let walkT = 0;
let moving = false;
const dust = [];

function createExplosion(x, y, color) {
  for (let i = 0; i < 15; i++) {
    particles.push({
      x: x,
      y: y,
      vx: (Math.random() - 0.5) * 15 * scale,
      vy: (Math.random() - 0.5) * 15 * scale,
      life: 1.0,
      color: color,
      type: 'particle'
    });
  }
}

// ======= FLOATING TEXT (LOVE +1) =======
function spawnFloatingText(x, y, text){
    particles.push({
        x: x, y: y,
        vx: 0, vy: -2 * scale,
        life: 1.0,
        text: text,
        color: "#ff6b81",
        type: 'text'
    });
}

// ======= LEVELS / STORY =======
let bgIndex = 0;          
let loopCount = 0;
let worldProgress = 0;
const LEVEL_LEN = 4200;

let gameEnded = false;
let leftLock = true;
const LEFT_UNLOCK_AT = 320; 

function nextScene(){
  bgIndex++;
  hp = MAX_HP;

  if(bgIndex >= BG_LIST.length){
    bgIndex = 0; 

    enemies.length = 0;
    stones.length = 0;
    bullets.length = 0;
    hearts.length = 0;
    particles.length = 0;
    worldProgress = 0;
    startFade();

    showCenterMsg("Hƒ∞SSEDƒ∞YORUM...\nE≈ûEK (VE A≈ûK) YAKINDA! ‚ù§Ô∏è", 120);
    
    spawnDonkeyNPC();
    return; 
  }

  showCenterMsg("Yeni B√∂lge ‚ûú " + (bgIndex+1) + "\nCan Fullendi! ‚ù§Ô∏è", 70);
  leftLock = false;

  enemies.length = 0;
  stones.length = 0;
  bullets.length = 0;
  hearts.length = 0;
  particles.length = 0; 

  worldProgress = 0;
  placeLevelObjects();
  startFade();
}

function spawnDonkeyNPC(){
    donkeyNPC = {
        x: window.innerWidth * 0.7, 
        y: 0, 
        w: 220 * scale,
        h: 220 * scale,
        t: 0
    };
    leftLock = false;
}

// ======= FADE IN/OUT =======
let fadeAlpha = 0;    
let fadeState = 0;    
function startFade(){
  fadeAlpha = 0;
  fadeState = 1;
}
function updateFade(){
  if(fadeState === 0) return;
  if(fadeState === 1){
    fadeAlpha += 0.08;
    if(fadeAlpha >= 1){
      fadeAlpha = 1;
      fadeState = 2;
    }
  }else if(fadeState === 2){
    fadeAlpha -= 0.08;
    if(fadeAlpha <= 0){
      fadeAlpha = 0;
      fadeState = 0;
    }
  }
}

// ======= SPAWN =======
function spawnEnemy(){
  if(donkeyNPC) return;

  const isElf = Math.random() < 0.5;
  enemies.push({
    type: isElf ? 'elf' : 'witch', 
    x: window.innerWidth + 120,
    y: groundY(),
    w: 180 * scale,
    h: 180 * scale,
    speed: (3.0 + Math.random()*0.8) * scale,
    t: Math.random()*10,
    flashTimer: 0
  });
}

function placeLevelObjects(){
  stones.length = 0;
  hearts.length = 0;

  const count = 1 + Math.floor(Math.random()*2); 
  for(let i=0;i<count;i++){
    const size = 86 * scale;
    const x = 900 + i * (700 + Math.random()*450); 
    stones.push({
      wx: x, 
      w: size,
      h: size,
      t: Math.random()*10
    });
  }

  const heartCount = 3 + Math.floor(Math.random()*3);
  for(let i=0; i<heartCount; i++){
      const size = 50 * scale;
      const x = 600 + i * (800 + Math.random()*300);
      const y = groundLineY() - (150 * scale) - (Math.random() * 100 * scale); 
      hearts.push({
          wx: x,
          y: y,
          w: size, h: size,
          t: Math.random() * 10
      });
  }
}

// ======= DAMAGE =======
let shake = 0;

function loseHp(reasonText){
  if(gameEnded || donkeyNPC) return; 

  hp--;
  shake = 15; 
  player.flashTimer = 8; 
  createExplosion(player.x + player.w/2, player.y + player.h/2, "red"); 

  showCenterMsg(reasonText, 70);
  if(hp<=0){
    setTimeout(() => {
        alert("GAME OVER üòà\nAma A≈ükƒ±n ƒ∞√ßin Tekrar Dene! ‚ù§Ô∏è");
        location.reload();
    }, 100);
  }
}

function winGame(){
    gameEnded = true;
    shake = 0;
    msg.style.display = "block";
    msg.style.background = "rgba(255,100,100,0.85)";
    msg.innerHTML = `
        üíñ TEBRƒ∞KLER A≈ûKIM! üíñ<br><br>
        E≈üeƒüi kurtardƒ±n artƒ±k gelebilirsindafsgsgs.<br>
        aferin <br><br>
        14 ≈ûubat Sevgililer g√ºn√ºn kutlu olsun :P üåπ<br>
        (Topladƒ±ƒüƒ±n Sevgi Puanƒ±: ${loveScore})
    `;
}

// ======= ACTIONS =======
function jump(){
  if(!player.grounded || gameEnded) return;
  player.vy = -18.8 * scale; 
  player.grounded = false;
}

// MELEE (ATK 1)
let attacking = false;
let atkTimer = 0;
const ATK_DURATION = 10;
const ATK_COOLDOWN = 18;
let atkCooldown = 0;

function knifeAttack(){ 
  if(gameEnded) return;
  if(attacking) return;
  if(atkCooldown > 0) return;

  playKnifeSfx(); // ‚úÖ VUR SESƒ∞

  attacking = true;
  atkTimer = ATK_DURATION;
  atkCooldown = ATK_COOLDOWN;
  shake = 3; 
}

// THROW (ATK 2)
let throwCooldown = 0;
const THROW_COOLDOWN_MAX = 40; 

function throwKnife(){
    if(gameEnded) return;
    if(throwCooldown > 0) return;

    playKnifeSfx(); // ‚úÖ ATMA SESƒ∞

    bullets.push({
        x: player.x + player.w * 0.6,
        y: player.y + player.h * 0.4,
        w: 60 * scale, 
        h: 20 * scale,
        speed: 15 * scale,
        rot: 0 
    });

    throwCooldown = THROW_COOLDOWN_MAX;
}

// ======= BUTTONS =======
const atkBtn = document.getElementById("atkBtn");
atkBtn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); knifeAttack(); });

const atk2Btn = document.getElementById("atk2Btn");
atk2Btn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); throwKnife(); });

const jumpBtn = document.getElementById("jumpBtn");
jumpBtn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); jump(); });

document.addEventListener("keydown", (e)=>{
  if(e.code === "Space") jump();
  if(e.code === "KeyZ") knifeAttack(); 
  if(e.code === "KeyX") throwKnife();  
});

function shrinkBox(obj, padX, padY){
  return {
    x: obj.x + padX,
    y: obj.y + padY,
    w: Math.max(1, obj.w - padX*2),
    h: Math.max(1, obj.h - padY*2),
  };
}

// ======= UPDATE =======
function update(){
  if(gameEnded) return;

  computeScale();

  player.w = 180 * scale;
  player.h = 180 * scale;
  player.speed = 6.6 * scale;

  let dir = joyVec.x;
  if(keys["a"] || keys["ArrowLeft"]) dir -= 1;
  if(keys["d"] || keys["ArrowRight"]) dir += 1;
  dir = clamp(dir, -1, 1);

  moving = Math.abs(dir) > 0.05;

  if(leftLock && worldProgress >= LEFT_UNLOCK_AT) leftLock = false;

  player.x += dir * player.speed;

  const minX = leftLock ? 120 : 0;
  player.x = Math.max(minX, Math.min(window.innerWidth - player.w, player.x));

  if(!donkeyNPC){
    if(dir > 0.15){
        worldProgress += player.speed * dir;
        if(worldProgress >= LEVEL_LEN){
        nextScene();
        return;
        }
    }
  }

  if(moving){
    walkT += 0.22;
    if(Math.random() < 0.28){
      dust.push({
        x: player.x + player.w*0.45 + (Math.random()*10-5),
        y: (player.y + player.h*0.92) + (Math.random()*6-3),
        vx: (Math.random()*0.9-0.45),
        vy: -(Math.random()*0.7),
        life: 18 + Math.random()*12,
        type: 'dust'
      });
    }
  }else{
    walkT *= 0.88;
  }

  for(let i=dust.length-1;i>=0;i--){
    const p = dust[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.06;
    p.life -= 1;
    if(p.life <= 0) dust.splice(i,1);
  }

  for(let i = particles.length - 1; i >= 0; i--){
      let p = particles[i];
      if(p.type === 'text'){
          p.y += p.vy;
          p.life -= 0.02;
      } else {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.5 * scale; 
          p.life -= 0.05;
      }
      if (p.life <= 0) particles.splice(i, 1);
  }

  if(player.flashTimer > 0) player.flashTimer--;

  const g = 0.88 * scale;
  player.vy += g;
  player.y += player.vy;

  const gy = groundY();
  if(player.y >= gy){
    player.y = gy;
    player.vy = 0;
    player.grounded = true;
  }

  if(donkeyNPC){
      donkeyNPC.w = 220 * scale;
      donkeyNPC.h = 220 * scale;
      donkeyNPC.y = groundLineY() - donkeyNPC.h;
      donkeyNPC.t += 0.05; 

      if(aabb(player, donkeyNPC)){
          winGame();
      }
  }

  if(throwCooldown > 0) throwCooldown--;

  for(let i = bullets.length - 1; i >= 0; i--){
      let b = bullets[i];
      b.x += b.speed; 
      b.rot += 0.3;   

      if(b.x > window.innerWidth){
          bullets.splice(i, 1);
          continue;
      }

      let hitEnemy = false;
      for(let ei = enemies.length - 1; ei >= 0; ei--){
          let e = enemies[ei];
          if(aabb(b, e)){
              shake = 8; 
              createExplosion(e.x + e.w/2, e.y + e.h/2, "#8a0303"); 
              enemies.splice(ei, 1); 
              hitEnemy = true;
              break;
          }
      }
      if(hitEnemy){
          bullets.splice(i, 1); 
      }
  }

  enemies.forEach(e=>{
    e.w = 180 * scale;
    e.h = 180 * scale;
    e.y = groundLineY() - e.h;

    if(e.flashTimer > 0) e.flashTimer--; 

    const toward = (player.x + player.w/2) - (e.x + e.w/2);
    e.x += Math.sign(toward) * e.speed; 
    e.t += 0.20;
  });
  enemies = enemies.filter(e => e.x > -800 && e.x < window.innerWidth + 800);

  if(atkCooldown > 0) atkCooldown--;

  if(attacking){
    atkTimer--;
    if(atkTimer <= 0) attacking = false;

    const knifeBox = {
      x: player.x + player.w * 0.72,
      y: player.y + player.h * 0.34,
      w: player.w * 0.46,
      h: player.h * 0.36
    };

    for(let ei = enemies.length - 1; ei >= 0; ei--){
      const e = enemies[ei];
      if(aabb(knifeBox, e)){
        shake = 12; 
        createExplosion(e.x + e.w/2, e.y + e.h/2, "#8a0303"); 
        enemies.splice(ei, 1);
        break;
      }
    }
  }

  for(let ei = enemies.length-1; ei>=0; ei--){
    const e = enemies[ei];
    const pBox = shrinkBox({x:player.x,y:player.y,w:player.w,h:player.h}, player.w*0.18, player.h*0.12);
    const eBox = shrinkBox({x:e.x,y:e.y,w:e.w,h:e.h}, e.w*0.12, e.h*0.10);

    if(aabb(pBox, eBox)){
      enemies.splice(ei,1);
      const msg2 = (e.type === 'elf') ? "ELF SENƒ∞ YAKTI üî•" : "CADI B√úY√ú YAPTI üîÆ";
      loseHp(msg2);
    }
  }

  for(let si = stones.length-1; si>=0; si--){
    const s = stones[si];
    const sx = s.wx - worldProgress; 
    const sy = groundLineY() - s.h;

    const stoneBox = shrinkBox({x:sx,y:sy,w:s.w,h:s.h}, s.w*0.18, s.h*0.18);
    const pBox = shrinkBox({x:player.x,y:player.y,w:player.w,h:player.h}, player.w*0.16, player.h*0.10);

    if(aabb(pBox, stoneBox)){
      stones.splice(si,1);
      loseHp("TA≈ûA TAKILDIN  ü§°\n1 CAN Gƒ∞TTƒ∞!");
    }
  }

  for(let hi = hearts.length-1; hi>=0; hi--){
      const h = hearts[hi];
      const hx = h.wx - worldProgress;
      const hy = h.y;

      const heartBox = {x:hx, y:hy, w:h.w, h:h.h};
      const pBox = shrinkBox({x:player.x,y:player.y,w:player.w,h:player.h}, player.w*0.1, player.h*0.1);

      if(aabb(pBox, heartBox)){
          hearts.splice(hi, 1);
          loveScore++;
          loveScoreEl.textContent = "Sevgi: " + loveScore + " ‚ù§Ô∏è";
          spawnFloatingText(player.x + player.w/2, player.y, "+1 SEVGƒ∞ ‚ù§Ô∏è");
      }
  }

  if(msgTimer > 0){
    msgTimer--;
    if(msgTimer === 0) msg.style.display = "none";
  }

  updateFade();
}

// ======= DRAW =======
function draw(assets){
  ctx.clearRect(0,0,window.innerWidth,window.innerHeight);

  ctx.imageSmoothingEnabled = true;
  const bgImg = assets.bgImgs[bgIndex];
  const parallaxSpeed = 0.4;
  let bgX = -(worldProgress * parallaxSpeed) % window.innerWidth;
  drawImageCover(bgImg, bgX, 0, window.innerWidth, window.innerHeight, BG_CROP_TOP, BG_CROP_BOTTOM);
  drawImageCover(bgImg, bgX + window.innerWidth, 0, window.innerWidth, window.innerHeight, BG_CROP_TOP, BG_CROP_BOTTOM);

  ctx.save();
  let sx = 0, sy = 0;
  if(shake > 0){
    sx = (Math.random()*2-1) * shake;
    sy = (Math.random()*2-1) * shake;
    shake *= 0.85; 
    if(shake < 0.5) shake = 0;
  }
  ctx.translate(sx, sy);

  ctx.imageSmoothingEnabled = false;

  const bob = moving ? Math.sin(walkT) * (4.0 * scale) : 0;
  const sway = moving ? Math.sin(walkT*0.7) * (2.0 * scale) : 0;

  ctx.save();
  ctx.translate(player.x + player.w/2, player.y + player.h/2);
  ctx.translate(0, bob);
  ctx.rotate(sway * 0.002);
  ctx.drawImage(assets.playerImg, -player.w/2, -player.h/2, player.w, player.h);
  if(player.flashTimer > 0){
      ctx.globalCompositeOperation = "source-atop";
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
  }
  ctx.restore();

  if(attacking){
    const t = (ATK_DURATION - atkTimer) / ATK_DURATION; 
    const x0 = player.x + player.w*0.82;
    const y0 = player.y + player.h*0.50;
    const x1 = x0 + player.w*(0.55 + 0.18*Math.sin(t*Math.PI));
    const y1 = y0 - player.h*(0.22 + 0.10*Math.sin(t*Math.PI));

    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = "rgba(255,255,255,0.95)";
    ctx.lineWidth = 3 * scale;
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  bullets.forEach(b => {
      ctx.save();
      ctx.translate(b.x + b.w/2, b.y + b.h/2);
      ctx.rotate(b.rot); 
      ctx.drawImage(assets.knifeImg, -b.w/2, -b.h/2, b.w, b.h);
      ctx.restore();
  });

  for(const p of particles){
      if(p.type === 'text'){
          ctx.fillStyle = p.color;
          ctx.font = "bold " + (24*scale) + "px monospace";
          ctx.textAlign = "center";
          ctx.globalAlpha = p.life;
          ctx.fillText(p.text, p.x, p.y);
          ctx.globalAlpha = 1.0;
      } else {
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life;
          ctx.fillRect(p.x, p.y, 6 * scale, 6 * scale); 
          ctx.globalAlpha = 1.0;
      }
  }

  ctx.fillStyle = "rgba(255,255,255,0.55)";
  for(const p of dust){
    ctx.fillRect(p.x, p.y, 2*scale, 2*scale);
  }

  if(donkeyNPC){
      const dbob = Math.sin(donkeyNPC.t) * (2.0 * scale);
      ctx.save();
      ctx.translate(donkeyNPC.x + donkeyNPC.w/2, donkeyNPC.y + donkeyNPC.h/2);
      ctx.translate(0, dbob);
      ctx.drawImage(assets.donkeyImg, -donkeyNPC.w/2, -donkeyNPC.h/2, donkeyNPC.w, donkeyNPC.h);
      ctx.fillStyle = "white";
      ctx.font = (16 * scale) + "px monospace";
      ctx.textAlign = "center";
      ctx.fillText("BENƒ∞ SEV! ‚ù§Ô∏è", 0, -donkeyNPC.h/2 - 10);
      ctx.restore();
  }

  enemies.forEach(e=>{
    const ebob = Math.sin(e.t) * (2.8 * scale);
    const esway = Math.sin(e.t*0.8) * (1.6 * scale);

    ctx.save();
    ctx.translate(e.x + e.w/2, e.y + e.h/2);
    ctx.translate(0, ebob);
    ctx.rotate(esway * 0.002);

    let enemySprite = (e.type === 'elf') ? assets.elfImg : assets.witchImg;
    ctx.drawImage(enemySprite, -e.w/2, -e.h/2, e.w, e.h);

    if(e.flashTimer > 0){
        ctx.globalCompositeOperation = "source-atop";
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.fillRect(-e.w/2, -e.h/2, e.w, e.h);
    }
    ctx.restore();
  });

  stones.forEach(s=>{
    const x = s.wx - worldProgress;
    const y = groundLineY() - s.h;
    const sbob = Math.sin((s.t += 0.05)) * (1.0 * scale);
    ctx.drawImage(assets.stoneImg, x, y + sbob, s.w, s.h);
  });

  hearts.forEach(h => {
      const x = h.wx - worldProgress;
      const hbob = Math.sin((h.t += 0.1)) * (5.0 * scale);
      ctx.drawImage(assets.loveImg, x, h.y + hbob, h.w, h.h);
  });

  ctx.restore(); 

  const heartSize = 30 * scale;
  const startX = 20;
  const startY = 20;
  const spacing = 35 * scale;

  for (let i = 0; i < hp; i++) {
      drawHeart(startX + (i * spacing), startY, heartSize, "#ff3333");
  }

  if(fadeAlpha > 0){
    ctx.fillStyle = `rgba(0,0,0,${fadeAlpha})`;
    ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
  }
}

// ======= START =======
(async ()=>{
  const assets = await loadAssets();

  /* ‚úÖ requestFull() kaldƒ±rƒ±ldƒ± */
  placeLevelObjects();

  setInterval(()=>{
    if(gameEnded || donkeyNPC) return; 
    if(enemies.length < 4 && Math.random() < 0.65){
      spawnEnemy();
    }
  }, 900);

  function loop(){
    update();
    draw(assets);
    requestAnimationFrame(loop);
  }
  loop();
})();
</script>
</body>
</html>
