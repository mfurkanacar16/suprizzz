<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Forest Fight</title>
<style>
  html,body{ margin:0; height:100%; overflow:hidden; background:#000; }
  body{ touch-action:none; }
  canvas{ display:block; width:100vw; height:100vh; }

  #ui{
    position:fixed; top:10px; left:10px; z-index:10;
    color:#fff; font: 18px monospace;
    background: rgba(0,0,0,0.35); padding:8px 10px; border-radius:8px;
  }

  #msg{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    color:#fff; font: 16px monospace; text-align:center;
    background: rgba(0,0,0,0.65); padding:14px 16px; border-radius:10px;
    z-index:10; display:none;
    white-space: pre-line;
  }

  /* === Dƒ∞KEY EKRAN UYARISI === */
  #rotateOverlay{
    position:fixed; inset:0; z-index:999;
    display:none;
    background: rgba(0,0,0,0.92);
    color:#fff;
    font: 18px monospace;
    align-items:center;
    justify-content:center;
    text-align:center;
    padding:24px;
  }
  #rotateOverlay .box{
    max-width:520px;
    background: rgba(255,255,255,0.06);
    border:1px solid rgba(255,255,255,0.12);
    border-radius:14px;
    padding:18px 16px;
  }
  #rotateOverlay .big{ font-size:42px; margin-bottom:10px; }
  #rotateOverlay .btn{
    margin-top:14px;
    display:inline-block;
    padding:10px 14px;
    border-radius:12px;
    background: rgba(255,255,255,0.12);
    border:1px solid rgba(255,255,255,0.18);
    cursor:pointer;
  }

  /* === JOYSTICK === */
  #joy{
    position:fixed;
    left:18px;
    bottom:18px;
    width:140px;
    height:140px;
    z-index:20;
    display:flex;
    align-items:center;
    justify-content:center;
    user-select:none;
    -webkit-user-select:none;
    touch-action:none;
  }
  #joyBase{
    width:140px; height:140px;
    border-radius:999px;
    background: rgba(255,255,255,0.08);
    border: 2px solid rgba(255,255,255,0.14);
    box-shadow: 0 14px 35px rgba(0,0,0,0.35) inset;
    position:relative;
  }
  #joyKnob{
    width:56px; height:56px;
    border-radius:999px;
    background: rgba(255,255,255,0.16);
    border: 2px solid rgba(255,255,255,0.22);
    position:absolute;
    left:50%; top:50%;
    transform: translate(-50%,-50%);
    box-shadow: 0 10px 22px rgba(0,0,0,0.30);
  }
  @media (max-width: 420px){
    #joy{ width:120px; height:120px; }
    #joyBase{ width:120px; height:120px; }
    #joyKnob{ width:50px; height:50px; }
  }

  /* Saƒü alt butonlar */
  .btnCircle{
    position:fixed;
    width:80px; /* Biraz k√º√ß√ºltt√ºm sƒ±ƒüsƒ±n diye */
    height:80px;
    border-radius:999px;
    z-index:20;
    background: rgba(255,255,255,0.10);
    border: 2px solid rgba(255,255,255,0.18);
    color:#fff;
    font: 12px monospace;
    display:flex;
    align-items:center;
    justify-content:center;
    user-select:none;
    -webkit-user-select:none;
    touch-action:none;
    text-align: center;
  }
  .btnCircle:active{ transform: translateY(1px); background: rgba(255,255,255,0.25); }
  
  /* Buton Konumlarƒ± */
  #jumpBtn{ right: 20px; bottom: 130px; }
  #atkBtn { right: 20px; bottom: 30px; background: rgba(255, 50, 50, 0.2); }
  #atk2Btn{ right: 110px; bottom: 30px; background: rgba(50, 150, 255, 0.2); } /* Yeni Buton */
</style>
</head>
<body>

<div id="ui">Can: <span id="hp">3</span></div>
<div id="msg"></div>

<div id="rotateOverlay">
  <div class="box">
    <div class="big">üì±‚ÜîÔ∏è</div>
    <div>OYUN YATAY OYNANIR<br>Telefonu <b>YAN</b> √ßevir.</div>
    <div class="btn" id="fsBtn">Tam Ekran A√ß</div>
  </div>
</div>

<div id="joy">
  <div id="joyBase">
    <div id="joyKnob"></div>
  </div>
</div>

<div id="jumpBtn" class="btnCircle">JUMP</div>
<div id="atkBtn" class="btnCircle">ATK</div>
<div id="atk2Btn" class="btnCircle">FIRLAT<br>(ATK2)</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const msg = document.getElementById("msg");

const rotateOverlay = document.getElementById("rotateOverlay");
const fsBtn = document.getElementById("fsBtn");

function resize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(window.innerWidth * dpr);
  canvas.height = Math.floor(window.innerHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener("resize", resize);
resize();

let hp = 3;
document.getElementById("hp").textContent = hp;

// ====== ASSETS ======
const BG_LIST = [
  "forest.png",
  "forest1.png",
  "forest2.png"
];

const SRC_PLAYER = "girl.png";
const SRC_WITCH  = "witch.png";
const SRC_ELF    = "elf.png";
const SRC_STONE  = "stone.png";
const SRC_KNIFE  = "knife.png"; // YENƒ∞ ASSET

const BG_CROP_TOP = 0.00;
const BG_CROP_BOTTOM = 0.00;
let GROUND_LINE = 0.78; 

function loadImg(src){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = () => reject(src);
    img.src = src;
  });
}

async function loadAssets(){
  msg.style.display = "block";
  msg.style.color = "#fff";
  msg.textContent = "Loading assets...";
  try{
    const bgImgs = await Promise.all(BG_LIST.map(loadImg));
    // Elf, Witch ve Knife'ƒ± y√ºkl√ºyoruz
    const [playerImg, witchImg, elfImg, stoneImg, knifeImg] = await Promise.all([
      loadImg(SRC_PLAYER),
      loadImg(SRC_WITCH),
      loadImg(SRC_ELF),
      loadImg(SRC_STONE),
      loadImg(SRC_KNIFE), // YENƒ∞ Y√úKLEME
    ]);
    msg.style.display = "none";
    return { bgImgs, playerImg, witchImg, elfImg, stoneImg, knifeImg };
  }catch(badSrc){
    msg.style.display = "block";
    msg.style.color = "#ff5a5a";
    msg.innerHTML =
      "ASSET BULUNAMADI ‚ùå<br><br>" +
      "Bulunamayan: <b>" + badSrc + "</b><br><br>" +
      "Dosya adƒ± / klas√∂r yolu aynƒ± mƒ± kontrol et.";
    throw new Error("Asset missing: " + badSrc);
  }
}

// ======== ORIENTATION / FULLSCREEN ========
function isPortrait(){
  return window.matchMedia && window.matchMedia("(orientation: portrait)").matches;
}
function updateOrientationUI(){
  rotateOverlay.style.display = isPortrait() ? "flex" : "none";
}
async function requestFull(){
  try{
    const el = document.documentElement;
    if(el.requestFullscreen) await el.requestFullscreen();
  }catch(e){}
  try{
    if(screen.orientation && screen.orientation.lock){
      await screen.orientation.lock("landscape");
    }
  }catch(e){}
  setTimeout(()=>{ resize(); }, 150);
}
fsBtn.addEventListener("click", requestFull);
window.addEventListener("orientationchange", ()=>{ updateOrientationUI(); setTimeout(resize,150); });
updateOrientationUI();

// ======== JOYSTICK ========
const joy = document.getElementById("joy");
const joyBase = document.getElementById("joyBase");
const joyKnob = document.getElementById("joyKnob");

let joyActive = false;
let joyCenter = {x:0,y:0};
let joyVec = {x:0,y:0}; 

function setJoyCenter(){
  const r = joyBase.getBoundingClientRect();
  joyCenter.x = r.left + r.width/2;
  joyCenter.y = r.top  + r.height/2;
}
setJoyCenter();
window.addEventListener("resize", setJoyCenter);

function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

function joyMove(clientX, clientY){
  const dx = clientX - joyCenter.x;
  const dy = clientY - joyCenter.y;
  const maxR = joyBase.getBoundingClientRect().width * 0.35;

  const dist = Math.hypot(dx,dy);
  const nx = dist > 0 ? dx/dist : 0;
  const ny = dist > 0 ? dy/dist : 0;

  const limited = Math.min(dist, maxR);
  const kx = nx * limited;
  const ky = ny * limited;

  joyKnob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;

  joyVec.x = clamp(kx / maxR, -1, 1);
  joyVec.y = clamp(ky / maxR, -1, 1);
}

function joyReset(){
  joyKnob.style.transform = "translate(-50%,-50%)";
  joyVec.x = 0; joyVec.y = 0;
}

joy.addEventListener("pointerdown", (e)=>{
  joyActive = true;
  joy.setPointerCapture(e.pointerId);
  joyMove(e.clientX, e.clientY);
});
joy.addEventListener("pointermove", (e)=>{
  if(!joyActive) return;
  joyMove(e.clientX, e.clientY);
});
joy.addEventListener("pointerup", ()=>{
  joyActive = false;
  joyReset();
});
joy.addEventListener("pointercancel", ()=>{
  joyActive = false;
  joyReset();
});

// ======== INPUT (PC) ========
let keys = {};
document.addEventListener("keydown", e=> keys[e.key]=true);
document.addEventListener("keyup", e=> keys[e.key]=false);

// ======== GAME STATE ========
let scale = 1;
function computeScale(){
  const s = window.innerHeight / 720;
  scale = Math.max(0.9, Math.min(1.6, s));
}

let player = {
  x:120, y:0, w:180, h:180,
  speed:6,
  vy:0,
  grounded:true
};

let bullets = []; // FIRLATILAN BI√áAKLAR
let enemies = [];
let stones = [];

function groundLineY(){ return window.innerHeight * GROUND_LINE; }
function groundY(){ return groundLineY() - player.h; }

function aabb(a,b){
  return a.x < b.x+b.w && a.x+a.w > b.x &&
         a.y < b.y+b.h && a.y+a.h > b.y;
}

// ‚Äúcover‚Äù √ßizim
function drawImageCover(img, dx, dy, dw, dh, cropTop=0, cropBottom=0){
  const swFull = img.width;
  const shFull = img.height;

  const cropY = Math.floor(shFull * cropTop);
  const cropH = Math.floor(shFull * (1 - cropTop - cropBottom));

  const sw = swFull;
  const sh = Math.max(1, cropH);

  const s = Math.max(dw / sw, dh / sh);
  const rw = sw * s;
  const rh = sh * s;

  const x = dx + (dw - rw) / 2;
  const y = dy + (dh - rh) / 2;

  ctx.drawImage(img, 0, cropY, sw, sh, x, y, rw, rh);
}

// ======= MESSAGE =======
let msgTimer = 0;
function showCenterMsg(text, frames=60){
  msg.style.display = "block";
  msg.style.color = "#fff";
  msg.textContent = text;
  msgTimer = frames;
}

// ======= FAKE WALK + DUST =======
let walkT = 0;
let moving = false;
const dust = [];

// ======= LEVELS / STORY =======
let bgIndex = 0;          // 0..2
let loopCount = 0;
const TOTAL_LOOPS = 3;
let worldProgress = 0;
const LEVEL_LEN = 4200;

let gameEnded = false;

// ilk sahnede sol kapalƒ±, biraz ilerleyince a√ß
let leftLock = true;
const LEFT_UNLOCK_AT = 320; 

function nextScene(){
  bgIndex++;
  if(bgIndex >= BG_LIST.length){
    bgIndex = 0;
    loopCount++;
  }

  if(loopCount >= TOTAL_LOOPS){
    gameEnded = true;
    showCenterMsg("Hƒ∞KAYE Bƒ∞TTƒ∞ ‚úÖ\n(sonunu sonra yazacaƒüƒ±z)", 999999);
  }else{
    showCenterMsg("Yeni B√∂lge ‚ûú " + (bgIndex+1) + "\n(devam üòà)", 70);
  }

  leftLock = false;

  enemies.length = 0;
  stones.length = 0;
  bullets.length = 0;

  worldProgress = 0;
  placeStones();
  startFade();
}

// ======= FADE IN/OUT =======
let fadeAlpha = 0;    
let fadeState = 0;    
function startFade(){
  fadeAlpha = 0;
  fadeState = 1;
}
function updateFade(){
  if(fadeState === 0) return;
  if(fadeState === 1){
    fadeAlpha += 0.08;
    if(fadeAlpha >= 1){
      fadeAlpha = 1;
      fadeState = 2;
    }
  }else if(fadeState === 2){
    fadeAlpha -= 0.08;
    if(fadeAlpha <= 0){
      fadeAlpha = 0;
      fadeState = 0;
    }
  }
}

// ======= SPAWN / PLACE =======
function spawnEnemy(){
  const isElf = Math.random() < 0.5;

  enemies.push({
    type: isElf ? 'elf' : 'witch', 
    x: window.innerWidth + 120,
    y: groundY(),
    w: 180 * scale,
    h: 180 * scale,
    speed: (3.0 + Math.random()*0.8) * scale,
    t: Math.random()*10
  });
}

function placeStones(){
  stones.length = 0;

  const count = 1 + Math.floor(Math.random()*2); 
  for(let i=0;i<count;i++){
    const size = 86 * scale;
    const x = 900 + i * (700 + Math.random()*450); 
    stones.push({
      wx: x, 
      w: size,
      h: size,
      t: Math.random()*10
    });
  }
}

// ======= DAMAGE =======
function loseHp(reasonText){
  hp--;
  document.getElementById("hp").textContent = hp;
  showCenterMsg(reasonText, 70);
  if(hp<=0){
    alert("GAME OVER üòà");
    location.reload();
  }
}

// ======= ACTIONS =======
function jump(){
  if(!player.grounded || gameEnded) return;
  player.vy = -18.8 * scale; 
  player.grounded = false;
}

// MELEE (ATK 1)
let attacking = false;
let atkTimer = 0;
const ATK_DURATION = 10;
const ATK_COOLDOWN = 18;
let atkCooldown = 0;
let shake = 0;

function knifeAttack(){ // Yakƒ±n d√∂v√º≈ü
  if(gameEnded) return;
  if(attacking) return;
  if(atkCooldown > 0) return;

  attacking = true;
  atkTimer = ATK_DURATION;
  atkCooldown = ATK_COOLDOWN;
  shake = 6;
}

// THROW (ATK 2)
let throwCooldown = 0;
const THROW_COOLDOWN_MAX = 40; // Mermi atma sƒ±klƒ±ƒüƒ±

function throwKnife(){
    if(gameEnded) return;
    if(throwCooldown > 0) return;

    // Bƒ±√ßak olu≈ütur
    bullets.push({
        x: player.x + player.w * 0.6,
        y: player.y + player.h * 0.4,
        w: 60 * scale, // Bƒ±√ßak boyutu
        h: 20 * scale,
        speed: 15 * scale,
        rot: 0 // D√∂nme a√ßƒ±sƒ±
    });

    throwCooldown = THROW_COOLDOWN_MAX;
}


// ======= BUTTONS =======
// ATK 1
const atkBtn = document.getElementById("atkBtn");
atkBtn.addEventListener("pointerdown", (e)=>{
  e.preventDefault();
  knifeAttack();
});

// ATK 2 (YENƒ∞)
const atk2Btn = document.getElementById("atk2Btn");
atk2Btn.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    throwKnife();
});

const jumpBtn = document.getElementById("jumpBtn");
jumpBtn.addEventListener("pointerdown", (e)=>{
  e.preventDefault();
  jump();
});

document.addEventListener("keydown", (e)=>{
  if(e.code === "Space") jump();
  if(e.code === "KeyZ") knifeAttack(); // Z tu≈üu yakƒ±n saldƒ±rƒ±
  if(e.code === "KeyX") throwKnife();  // X tu≈üu fƒ±rlatma
});

// ======= HITBOX HELPERS =======
function shrinkBox(obj, padX, padY){
  return {
    x: obj.x + padX,
    y: obj.y + padY,
    w: Math.max(1, obj.w - padX*2),
    h: Math.max(1, obj.h - padY*2),
  };
}

// ======= UPDATE =======
function update(){
  if(gameEnded) return;

  computeScale();

  player.w = 180 * scale;
  player.h = 180 * scale;
  player.speed = 6.6 * scale;

  let dir = joyVec.x;
  if(keys["a"] || keys["ArrowLeft"]) dir -= 1;
  if(keys["d"] || keys["ArrowRight"]) dir += 1;
  dir = clamp(dir, -1, 1);

  moving = Math.abs(dir) > 0.05;

  if(leftLock && worldProgress >= LEFT_UNLOCK_AT) leftLock = false;

  player.x += dir * player.speed;

  const minX = leftLock ? 120 : 0;
  player.x = Math.max(minX, Math.min(window.innerWidth - player.w, player.x));

  if(dir > 0.15){
    worldProgress += player.speed * dir;

    if(worldProgress >= LEVEL_LEN){
      nextScene();
      return;
    }
  }

  // ==== WALK EFFECT ====
  if(moving){
    walkT += 0.22;
    if(Math.random() < 0.28){
      dust.push({
        x: player.x + player.w*0.45 + (Math.random()*10-5),
        y: (player.y + player.h*0.92) + (Math.random()*6-3),
        vx: (Math.random()*0.9-0.45),
        vy: -(Math.random()*0.7),
        life: 18 + Math.random()*12
      });
    }
  }else{
    walkT *= 0.88;
  }

  for(let i=dust.length-1;i>=0;i--){
    const p = dust[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.06;
    p.life -= 1;
    if(p.life <= 0) dust.splice(i,1);
  }

  // ==== JUMP PHYSICS ====
  const g = 0.88 * scale;
  player.vy += g;
  player.y += player.vy;

  const gy = groundY();
  if(player.y >= gy){
    player.y = gy;
    player.vy = 0;
    player.grounded = true;
  }

  // ===== BULLETS (ATK 2) =====
  if(throwCooldown > 0) throwCooldown--;

  for(let i = bullets.length - 1; i >= 0; i--){
      let b = bullets[i];
      b.x += b.speed; // Saƒüa git
      b.rot += 0.3;   // D√∂nme efekti

      // Ekran dƒ±≈üƒ±na √ßƒ±karsa sil
      if(b.x > window.innerWidth){
          bullets.splice(i, 1);
          continue;
      }

      // Mermi d√º≈ümana √ßarptƒ± mƒ±?
      let hitEnemy = false;
      for(let ei = enemies.length - 1; ei >= 0; ei--){
          let e = enemies[ei];
          // Basit √ßarpƒ±≈üma kontrol√º
          if(aabb(b, e)){
              enemies.splice(ei, 1); // D√º≈ümanƒ± sil
              hitEnemy = true;
              break;
          }
      }

      if(hitEnemy){
          bullets.splice(i, 1); // Mermiyi de sil
          shake = 5; // Hafif sarsƒ±ntƒ±
      }
  }


  // ===== ENEMY AI =====
  enemies.forEach(e=>{
    e.w = 180 * scale;
    e.h = 180 * scale;
    e.y = groundLineY() - e.h;

    const toward = (player.x + player.w/2) - (e.x + e.w/2);
    e.x += Math.sign(toward) * e.speed; // kƒ±za yakla≈ü
    e.t += 0.20;
  });
  enemies = enemies.filter(e => e.x > -800 && e.x < window.innerWidth + 800);

  // ===== MELEE timers =====
  if(atkCooldown > 0) atkCooldown--;

  if(attacking){
    atkTimer--;
    if(atkTimer <= 0) attacking = false;

    const knifeBox = {
      x: player.x + player.w * 0.72,
      y: player.y + player.h * 0.34,
      w: player.w * 0.46,
      h: player.h * 0.36
    };

    for(let ei = enemies.length - 1; ei >= 0; ei--){
      const e = enemies[ei];
      if(aabb(knifeBox, e)){
        enemies.splice(ei, 1);
        shake = 9;
        break;
      }
    }
  }

  // ===== COLLISIONS (PLAYER vs ENEMY) =====
  for(let ei = enemies.length-1; ei>=0; ei--){
    const e = enemies[ei];
    const pBox = shrinkBox({x:player.x,y:player.y,w:player.w,h:player.h}, player.w*0.18, player.h*0.12);
    const eBox = shrinkBox({x:e.x,y:e.y,w:e.w,h:e.h}, e.w*0.12, e.h*0.10);

    if(aabb(pBox, eBox)){
      enemies.splice(ei,1);
      const msg = (e.type === 'elf') ? "ELF SENƒ∞ YAKTI üî•" : "CADI B√úY√ú YAPTI üîÆ";
      loseHp(msg);
    }
  }

  for(let si = stones.length-1; si>=0; si--){
    const s = stones[si];
    const sx = s.wx - worldProgress; 
    const sy = groundLineY() - s.h;

    const stoneBox = shrinkBox({x:sx,y:sy,w:s.w,h:s.h}, s.w*0.18, s.h*0.18);
    const pBox = shrinkBox({x:player.x,y:player.y,w:player.w,h:player.h}, player.w*0.16, player.h*0.10);

    if(aabb(pBox, stoneBox)){
      stones.splice(si,1);
      loseHp("TA≈ûA TAKILDI ENAYƒ∞ ü§°\n1 CAN Gƒ∞TTƒ∞!");
    }
  }

  if(msgTimer > 0){
    msgTimer--;
    if(msgTimer === 0) msg.style.display = "none";
  }

  updateFade();
}

// ======= DRAW =======
function draw(assets){
  let sx = 0, sy = 0;
  if(shake > 0){
    sx = (Math.random()*2-1) * shake;
    sy = (Math.random()*2-1) * shake;
    shake *= 0.75;
    if(shake < 0.5) shake = 0;
  }

  ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
  ctx.save();
  ctx.translate(sx, sy);

  // BG
  ctx.imageSmoothingEnabled = true;
  const bgImg = assets.bgImgs[bgIndex];
  drawImageCover(bgImg, 0, 0, window.innerWidth, window.innerHeight, BG_CROP_TOP, BG_CROP_BOTTOM);

  // pixel sprite
  ctx.imageSmoothingEnabled = false;

  // PLAYER
  const bob = moving ? Math.sin(walkT) * (4.0 * scale) : 0;
  const sway = moving ? Math.sin(walkT*0.7) * (2.0 * scale) : 0;

  ctx.save();
  ctx.translate(player.x + player.w/2, player.y + player.h/2);
  ctx.translate(0, bob);
  ctx.rotate(sway * 0.002);
  ctx.drawImage(assets.playerImg, -player.w/2, -player.h/2, player.w, player.h);
  ctx.restore();

  // MELEE SLASH
  if(attacking){
    const t = (ATK_DURATION - atkTimer) / ATK_DURATION; 
    const x0 = player.x + player.w*0.82;
    const y0 = player.y + player.h*0.50;
    const x1 = x0 + player.w*(0.55 + 0.18*Math.sin(t*Math.PI));
    const y1 = y0 - player.h*(0.22 + 0.10*Math.sin(t*Math.PI));

    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = "rgba(255,255,255,0.95)";
    ctx.lineWidth = 3 * scale;
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // BULLETS (KNIFE)
  bullets.forEach(b => {
      ctx.save();
      ctx.translate(b.x + b.w/2, b.y + b.h/2);
      ctx.rotate(b.rot); // Bƒ±√ßaƒüƒ± d√∂nd√ºr
      ctx.drawImage(assets.knifeImg, -b.w/2, -b.h/2, b.w, b.h);
      ctx.restore();
  });

  // dust
  ctx.fillStyle = "rgba(255,255,255,0.55)";
  for(const p of dust){
    ctx.fillRect(p.x, p.y, 2*scale, 2*scale);
  }

  // ENEMIES
  enemies.forEach(e=>{
    const ebob = Math.sin(e.t) * (2.8 * scale);
    const esway = Math.sin(e.t*0.8) * (1.6 * scale);

    ctx.save();
    ctx.translate(e.x + e.w/2, e.y + e.h/2);
    ctx.translate(0, ebob);
    ctx.rotate(esway * 0.002);

    let enemySprite = (e.type === 'elf') ? assets.elfImg : assets.witchImg;
    ctx.drawImage(enemySprite, -e.w/2, -e.h/2, e.w, e.h);
    ctx.restore();
  });

  // STONES
  stones.forEach(s=>{
    const x = s.wx - worldProgress;
    const y = groundLineY() - s.h;
    const sbob = Math.sin((s.t += 0.05)) * (1.0 * scale);
    ctx.drawImage(assets.stoneImg, x, y + sbob, s.w, s.h);
  });

  ctx.restore();

  if(fadeAlpha > 0){
    ctx.fillStyle = `rgba(0,0,0,${fadeAlpha})`;
    ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
  }
}

// ======= START =======
(async ()=>{
  const assets = await loadAssets();

  requestFull();
  placeStones();

  setInterval(()=>{
    if(gameEnded) return;
    if(enemies.length < 4 && Math.random() < 0.65){
      spawnEnemy();
    }
  }, 900);

  function loop(){
    update();
    draw(assets);
    requestAnimationFrame(loop);
  }
  loop();
})();
</script>
</body>
</html>
